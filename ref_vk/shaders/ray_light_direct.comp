#version 460 core
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_control_flow_attributes : require
#extension GL_EXT_ray_query: require

#include "utils.glsl"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

#include "ray_light_direct_iface.h"

#define GLSL
#include "ray_interop.h"
#undef GLSL

#define X(index, name, format) layout(set=0,binding=index,format) uniform readonly image2D name;
RAY_LIGHT_DIRECT_INPUTS(X)
#undef X
#define X(index, name, format) layout(set=0,binding=index,format) uniform writeonly image2D out_image_##name;
RAY_LIGHT_DIRECT_OUTPUTS(X)
#undef X

layout(set = 0, binding = 1) uniform accelerationStructureEXT tlas;
layout(set = 0, binding = 2) uniform UBO { UniformBuffer ubo; };

#include "ray_kusochki.glsl"

#define RAY_QUERY

#define BINDING_LIGHTS 7
#define BINDING_LIGHT_CLUSTERS 8
#include "light.glsl"

void readNormals(ivec2 uv, out vec3 geometry_normal, out vec3 shading_normal) {
	const vec4 n = imageLoad(normals_gs, uv);
	geometry_normal = normalDecode(n.xy);
	shading_normal = normalDecode(n.zw);
}

void main() {
	//vec2 uv = (gl_LaunchIDEXT.xy + .5) / gl_LaunchSizeEXT.xy * 2. - 1.;
	const ivec2 res = ivec2(imageSize(position_t));
	const ivec2 pix = ivec2(gl_GlobalInvocationID);
	const vec2 uv = (pix + .5) / res * 2. - 1.;

	rand01_state = ubo.random_seed + gl_GlobalInvocationID.x * 1833 +  gl_GlobalInvocationID.y * 31337;

	// FIXME incorrect for reflection/refraction
	vec4 target    = ubo.inv_proj * vec4(uv.x, uv.y, 1, 1);
	vec3 direction = normalize((ubo.inv_view * vec4(target.xyz, 0)).xyz);

	MaterialProperties material;
	material.baseColor = vec3(1.);
	material.emissive = vec3(0.f);
	material.metalness = 0.f; // TODO
	material.roughness = 1.f; // TODO

	const vec3 pos = imageLoad(position_t, pix).xyz;

	vec3 geometry_normal, shading_normal;
	readNormals(pix, geometry_normal, shading_normal);

	const vec3 throughput = vec3(1.);
	vec3 diffuse = vec3(0.), specular = vec3(0.);
	computeLighting(pos + geometry_normal * .001, shading_normal, throughput, -direction, material, diffuse, specular);

	//specular = shading_normal;
	//diffuse = geometry_normal;
	//diffuse = shading_normal;
	imageStore(out_image_light_poly_diffuse, pix, vec4(diffuse, 0.f));
	//imageStore(out_image_light_diffuse, pix, vec4(1.,0.,0.f, 0.f));
	imageStore(out_image_light_poly_specular, pix, vec4(specular, 0.f));
}
