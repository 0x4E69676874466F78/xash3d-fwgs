#version 460 core

#extension GL_EXT_ray_tracing : require
// #extension GL_EXT_shader_16bit_storage : require
// #extension GL_EXT_shader_8bit_storage : require

// FIXME shader specialization
//layout(local_size_x = 16, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0, set = 0, rgba8) uniform image2D image;
layout(binding = 1, set = 0) uniform accelerationStructureEXT tlas;
layout(binding = 2, set = 0) uniform UBO {
	mat4 inv_proj, inv_view;

	// TODO combine
	//int num_lights;
	//Light lights[];
} ubo;

#if 0
struct Kusok {
	uint index_offset;
	uint vertex_offset;
	uint triangles;

	// Material
	uint texture;
	float roughness;
};

struct Vertex {
	vec3 pos;
	vec3 normal;
	vec2 gl_tc;
	vec2 lm_tc;
};

layout(std430, binding = 3, set = 0) readonly buffer Kusochki { Kusok kusochki[]; };
layout(std430, binding = 4, set = 0) readonly buffer Indices { uint16_t indices[]; };
layout(std430, binding = 5, set = 0) readonly buffer Vertices { Vertex vertices[]; };

// TODO #include, use from here and regular shader
struct Light {
	vec4 pos_r;
	vec4 color;
};
// FIXME what should this be?
const float dlight_attenuation_const = 20000.;
// TODO specialize in vk_rtx.c
layout (constant_id = 0) const uint max_dlights = 32;
layout(set=0,binding=6) uniform UBODLights {
	uint num_lights;
	Light lights[max_dlights];
};

struct EmissiveKusok {
	uint kusok_index;
	vec3 emissive_color;
	vec4 tx_row_x, tx_row_y, tx_row_z;
};

layout (constant_id = 1) const uint MAX_EMISSIVE_KUSOCHKI = 256;
layout (set = 0, binding = 7/*, align=4*/) uniform UBOEmissiveKusochki {
	uint num_kusochki;
	EmissiveKusok kusochki[MAX_EMISSIVE_KUSOCHKI];
} emissive_kusochki;

layout(binding = 8, set = 0, rgba8) uniform readonly image2D previous_frame;

layout (constant_id = 2) const uint MAX_VISIBLE_DLIGHTS = 255;//15;
layout (constant_id = 3) const uint MAX_VISIBLE_SURFACE_LIGHTS = 255;//31;

const uint LIGHT_CLUSTER_SIZE = 2 + MAX_VISIBLE_DLIGHTS + MAX_VISIBLE_SURFACE_LIGHTS;
const uint LIGHT_CLUSTER_NUM_DLIGHTS_OFFSET = 0;
const uint LIGHT_CLUSTER_NUM_EMISSIVE_SURFACES_OFFSET = 1;
const uint LIGHT_CLUSTER_DLIGHTS_DATA_OFFSET = 2;
const uint LIGHT_CLUSTER_EMISSIVE_SURFACES_DATA_OFFSET = 3 + MAX_VISIBLE_DLIGHTS;

struct LightCluster {
	uint8_t num_dlights;
	uint8_t num_emissive_surfaces;
	uint8_t dlights[MAX_VISIBLE_DLIGHTS];
	uint8_t emissive_surfaces[MAX_VISIBLE_SURFACE_LIGHTS];
};

// FIMXE specialize
layout (constant_id = 4) const float LIGHT_GRID_CELL_SIZE = 256.;
layout (constant_id = 5) const uint MAX_LIGHT_CLUSTERS = 32768;
const uint HACK_OFFSET = 0;
layout (set = 0, binding = 9, align = 1) readonly buffer UBOLightClusters {
	ivec3 grid_min, grid_size;
	//uint8_t clusters_data[MAX_LIGHT_CLUSTERS * LIGHT_CLUSTER_SIZE + HACK_OFFSET];
	LightCluster clusters[MAX_LIGHT_CLUSTERS];
} light_grid;

layout (constant_id = 6) const uint MAX_TEXTURES = 4096;
layout (set = 0, binding = 10) uniform sampler2D textures[MAX_TEXTURES];

layout (push_constant) uniform PC {
	float t;
	int bounces;
	float prev_frame_blend_factor;
} pc;
#endif

layout(location = 0) rayPayloadEXT vec4 ray_result;

void main() {
	vec2 uv = (gl_LaunchIDEXT.xy + .5) / gl_LaunchSizeEXT.xy * 2. - 1.;

	vec4 origin    = ubo.inv_view * vec4(0, 0, 0, 1);
	vec4 target    = ubo.inv_proj * vec4(uv.x, uv.y, 1, 1);
	vec4 direction = ubo.inv_view * vec4(normalize(target.xyz), 0);

	const uint sbt_offset = 0;
	const uint sbt_stride = 0;
	const uint miss_index = 0;
	const float L = 10000.;
	traceRayEXT(tlas, gl_RayFlagsOpaqueEXT, 0xff,
		sbt_offset, sbt_stride, miss_index,
		origin.rgb, 0., direction.rgb, L, 0);

	//imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(vec3(uv.x * uv.y), 1.)); return;
	//vec3 c = vec3(fract(gl_LaunchIDEXT.xy / 10.), 1.);
	imageStore(image, ivec2(gl_LaunchIDEXT.xy), ray_result);//vec4(c, 1.));
}