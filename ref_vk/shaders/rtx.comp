#version 460
#extension GL_EXT_ray_query : require
#extension GL_EXT_shader_16bit_storage : require

// FIXME shader specialization
layout(local_size_x = 16, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0, set = 0, rgba8) uniform image2D image;
layout(binding = 1, set = 0) uniform accelerationStructureEXT tlas;
layout(binding = 2, set = 0) uniform UBO {
	mat4 inv_proj, inv_view;

	// TODO combine
	//int num_lights;
	//Light lights[];
} ubo;

struct Kusok {
	uint index_offset;
	uint vertex_offset;
};

struct Vertex {
	vec3 pos;
	vec3 normal;
	vec2 gl_tc;
	vec2 lm_tc;
};

layout(std430, binding = 3, set = 0) readonly buffer Kusochki { Kusok kusochki[]; };
layout(std430, binding = 4, set = 0) readonly buffer Indices { uint16_t indices[]; };
layout(std430, binding = 5, set = 0) readonly buffer Vertices { Vertex vertices[]; };

// TODO #include, use from here and regular shader
struct Light {
	vec4 pos_r;
	vec4 color;
};
// FIXME what should this be?
const float dlight_attenuation_const = 20000.;
// TODO specialize in vk_rtx.c
layout (constant_id = 1) const uint max_dlights = 32;
layout(set=0,binding=6) uniform UBODLights {
	uint num_lights;
	Light lights[max_dlights];
};

// TODO find better random function
float rand01_state;
float rand01() {
	return rand01_state = fract(sin(rand01_state)*54873.35729);
}

layout (push_constant) uniform PC {
	float t;
} pc;

void main() {
	vec2 res = imageSize(image);
	vec2 uv = (gl_GlobalInvocationID.xy + .5) / res * 2. - 1.;

	vec4 origin    = ubo.inv_view * vec4(0, 0, 0, 1);
	vec4 target    = ubo.inv_proj * vec4(uv.x, uv.y, 1, 1);
	vec4 direction = ubo.inv_view * vec4(normalize(target.xyz), 0);

	vec3 C = vec3(0.);
	vec3 O = origin.xyz, D=direction.xyz;

	const float L = 10000.;
	rayQueryEXT rayQuery;
	rayQueryInitializeEXT(rayQuery, tlas, gl_RayFlagsOpaqueEXT, 0xff, O, 0., D, L);
	while(rayQueryProceedEXT(rayQuery)) {}
	const float l = rayQueryGetIntersectionTEXT(rayQuery, true);
	if (rayQueryGetIntersectionTypeEXT(rayQuery, true) != gl_RayQueryCommittedIntersectionTriangleEXT) {
		C = vec3(1., 0., 1.);
	} else {
		vec3 pos = O+D*l;

		//const int instance_index = rayQueryGetIntersectionInstanceIdEXT(rayQuery, true);
		const int instance_index = rayQueryGetIntersectionInstanceCustomIndexEXT(rayQuery, true);
		/* C.r = float(instance_index & 15) / 15.f; */
		/* C.g = float((instance_index >> 4) & 15) / 15.f; */
		/* C.b = float((instance_index >> 8) & 15) / 15.f; */

		//rayQueryGetIntersectionGeometryIndexEXT
		const int prim_index = rayQueryGetIntersectionPrimitiveIndexEXT(rayQuery, true);

		/* C.r = float(prim_index & 7) / 7.f; */
		/* C.g = float((prim_index >> 3) & 7) / 7.f; */
		/* C.b = float((prim_index >> 6) & 7) / 7.f; */

		const uint first_index_offset = kusochki[instance_index].index_offset + prim_index * 3;
		const uint vi1 = uint(indices[first_index_offset+0]) + kusochki[instance_index].vertex_offset;
		const uint vi2 = uint(indices[first_index_offset+1]) + kusochki[instance_index].vertex_offset;
		const uint vi3 = uint(indices[first_index_offset+2]) + kusochki[instance_index].vertex_offset;
		const vec3 n1 = vertices[vi1].normal;
		const vec3 n2 = vertices[vi2].normal;
		const vec3 n3 = vertices[vi3].normal;

		const vec2 bary = rayQueryGetIntersectionBarycentricsEXT(rayQuery, true);
		const vec3 normal = normalize(n1 * (1. - bary.x - bary.y) + n2 * bary.x + n3 * bary.y);

		//const vec3 normal = vertices[kusochki[instance_index].vertex_offset].normal;

		//const vec3 normal = vertices[prim_index * 3].normal;
		//C = normal * .5 + .5;

		/* C.r = float(first_vertex_index & 31) / 31.f; */
		/* C.g = float((first_vertex_index >> 5) & 31) / 31.f; */
		/* C.b = float((first_vertex_index >> 10) & 31) / 31.f; */

		const vec3 baseColor = vec3(1.);
		rand01_state = fract((pos.x + pos.y + pos.z)/100.) + uv.x + uv.y + pc.t;
		for (uint i = 0; i < num_lights; ++i) {
			const vec4 light_pos_r = lights[i].pos_r;
			const vec3 light_color = lights[i].color.rgb;

			rand01_state += fract((light_pos_r.x + light_pos_r.y + light_pos_r.z)/100.);

			// Find random point on a sphere
			// TODO proper BRDF importance sampling and correct random point distribution
			vec3 rnd = normalize(vec3(rand01()*2.-1., rand01()*2.-1., rand01()*2.-1.));
			if (dot(rnd, pos - light_pos_r.xyz) < 0.) rnd = -rnd;

			// TODO fudge this
			const float light_r_scaler = 10.;
			const vec3 light_dir = light_pos_r.xyz - pos + rnd * light_pos_r.w / light_r_scaler;
			const vec3 light_dir_norm = normalize(light_dir);
			const float dot_ld_norm = dot(light_dir_norm, normal);
			if (dot_ld_norm <= 0.)
				continue;

			const float d2 = dot(light_dir, light_dir);
			const float light_dist = sqrt(d2);

			rayQueryEXT shadowRayQuery;
			rayQueryInitializeEXT(shadowRayQuery, tlas,
				gl_RayFlagsOpaqueEXT | gl_RayFlagsTerminateOnFirstHitEXT,
				0xff,
				pos + normal * .01, 0., light_dir_norm, light_dist);
			while(rayQueryProceedEXT(shadowRayQuery)) {}
			if (rayQueryGetIntersectionTypeEXT(shadowRayQuery, true) != gl_RayQueryCommittedIntersectionNoneEXT)
				continue;

			const float r2 = light_pos_r.w * light_pos_r.w;
			// TODO this is a bad approximation
			const float attenuation = dlight_attenuation_const / (d2 + r2 * .5);
			C += baseColor.rgb * light_color * dot_ld_norm * attenuation;
		}
	}

	imageStore(image, ivec2(gl_GlobalInvocationID.xy), vec4(C, 1.));
}
